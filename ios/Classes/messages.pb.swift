// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Messages_CommandCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case `open` // = 0
  case close // = 1
  case torch // = 2
  case zoom // = 3
  case closeImageProxy // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .open
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .open
    case 1: self = .close
    case 2: self = .torch
    case 3: self = .zoom
    case 4: self = .closeImageProxy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .open: return 0
    case .close: return 1
    case .torch: return 2
    case .zoom: return 3
    case .closeImageProxy: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Messages_CommandCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Messages_CommandCategory] = [
    .open,
    .close,
    .torch,
    .zoom,
    .closeImageProxy,
  ]
}

#endif  // swift(>=4.2)

enum Messages_EventCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case quarterTurnsChanged // = 0
  case torchStateChanged // = 1
  case zoomValueChanged // = 2
  case imageProxyReceived // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .quarterTurnsChanged
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .quarterTurnsChanged
    case 1: self = .torchStateChanged
    case 2: self = .zoomValueChanged
    case 3: self = .imageProxyReceived
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .quarterTurnsChanged: return 0
    case .torchStateChanged: return 1
    case .zoomValueChanged: return 2
    case .imageProxyReceived: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Messages_EventCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Messages_EventCategory] = [
    .quarterTurnsChanged,
    .torchStateChanged,
    .zoomValueChanged,
    .imageProxyReceived,
  ]
}

#endif  // swift(>=4.2)

enum Messages_CameraFacing: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case back // = 0
  case front // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .back
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .back
    case 1: self = .front
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .back: return 0
    case .front: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Messages_CameraFacing: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Messages_CameraFacing] = [
    .back,
    .front,
  ]
}

#endif  // swift(>=4.2)

struct Messages_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var category: Messages_CommandCategory = .open

  var stub: Messages_Command.OneOf_Stub? = nil

  var openArguments: Messages_OpenArguments {
    get {
      if case .openArguments(let v)? = stub {return v}
      return Messages_OpenArguments()
    }
    set {stub = .openArguments(newValue)}
  }

  var torchState: Bool {
    get {
      if case .torchState(let v)? = stub {return v}
      return false
    }
    set {stub = .torchState(newValue)}
  }

  var zoomValue: Double {
    get {
      if case .zoomValue(let v)? = stub {return v}
      return 0
    }
    set {stub = .zoomValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Stub: Equatable {
    case openArguments(Messages_OpenArguments)
    case torchState(Bool)
    case zoomValue(Double)

  #if !swift(>=4.1)
    static func ==(lhs: Messages_Command.OneOf_Stub, rhs: Messages_Command.OneOf_Stub) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openArguments, .openArguments): return {
        guard case .openArguments(let l) = lhs, case .openArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.torchState, .torchState): return {
        guard case .torchState(let l) = lhs, case .torchState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zoomValue, .zoomValue): return {
        guard case .zoomValue(let l) = lhs, case .zoomValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Messages_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var category: Messages_EventCategory = .quarterTurnsChanged

  var stub: Messages_Event.OneOf_Stub? = nil

  var quarterTurns: Int32 {
    get {
      if case .quarterTurns(let v)? = stub {return v}
      return 0
    }
    set {stub = .quarterTurns(newValue)}
  }

  var torchState: Bool {
    get {
      if case .torchState(let v)? = stub {return v}
      return false
    }
    set {stub = .torchState(newValue)}
  }

  var zoomValue: Double {
    get {
      if case .zoomValue(let v)? = stub {return v}
      return 0
    }
    set {stub = .zoomValue(newValue)}
  }

  var image: Messages_ImageProxy {
    get {
      if case .image(let v)? = stub {return v}
      return Messages_ImageProxy()
    }
    set {stub = .image(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Stub: Equatable {
    case quarterTurns(Int32)
    case torchState(Bool)
    case zoomValue(Double)
    case image(Messages_ImageProxy)

  #if !swift(>=4.1)
    static func ==(lhs: Messages_Event.OneOf_Stub, rhs: Messages_Event.OneOf_Stub) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.quarterTurns, .quarterTurns): return {
        guard case .quarterTurns(let l) = lhs, case .quarterTurns(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.torchState, .torchState): return {
        guard case .torchState(let l) = lhs, case .torchState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zoomValue, .zoomValue): return {
        guard case .zoomValue(let l) = lhs, case .zoomValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Messages_OpenArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var selector: Messages_CameraSelector {
    get {return _selector ?? Messages_CameraSelector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {self._selector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selector: Messages_CameraSelector? = nil
}

struct Messages_CameraSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var facing: Messages_CameraFacing = .back

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Messages_CameraValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var textureValue: Messages_TextureValue {
    get {return _textureValue ?? Messages_TextureValue()}
    set {_textureValue = newValue}
  }
  /// Returns true if `textureValue` has been explicitly set.
  var hasTextureValue: Bool {return self._textureValue != nil}
  /// Clears the value of `textureValue`. Subsequent reads from it will return its default value.
  mutating func clearTextureValue() {self._textureValue = nil}

  var torchValue: Messages_TorchValue {
    get {return _torchValue ?? Messages_TorchValue()}
    set {_torchValue = newValue}
  }
  /// Returns true if `torchValue` has been explicitly set.
  var hasTorchValue: Bool {return self._torchValue != nil}
  /// Clears the value of `torchValue`. Subsequent reads from it will return its default value.
  mutating func clearTorchValue() {self._torchValue = nil}

  var zoomValue: Messages_ZoomValue {
    get {return _zoomValue ?? Messages_ZoomValue()}
    set {_zoomValue = newValue}
  }
  /// Returns true if `zoomValue` has been explicitly set.
  var hasZoomValue: Bool {return self._zoomValue != nil}
  /// Clears the value of `zoomValue`. Subsequent reads from it will return its default value.
  mutating func clearZoomValue() {self._zoomValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _textureValue: Messages_TextureValue? = nil
  fileprivate var _torchValue: Messages_TorchValue? = nil
  fileprivate var _zoomValue: Messages_ZoomValue? = nil
}

struct Messages_TextureValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var width: Int32 = 0

  var height: Int32 = 0

  var quarterTurns: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Messages_TorchValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var available: Bool = false

  var state: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Messages_ZoomValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minimum: Double = 0

  var maximum: Double = 0

  var value: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Messages_ImageProxy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var data: Data = Data()

  var width: Int32 = 0

  var height: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "messages"

extension Messages_CommandCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN"),
    1: .same(proto: "CLOSE"),
    2: .same(proto: "TORCH"),
    3: .same(proto: "ZOOM"),
    4: .same(proto: "CLOSE_IMAGE_PROXY"),
  ]
}

extension Messages_EventCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "QUARTER_TURNS_CHANGED"),
    1: .same(proto: "TORCH_STATE_CHANGED"),
    2: .same(proto: "ZOOM_VALUE_CHANGED"),
    3: .same(proto: "IMAGE_PROXY_RECEIVED"),
  ]
}

extension Messages_CameraFacing: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BACK"),
    1: .same(proto: "FRONT"),
  ]
}

extension Messages_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "category"),
    3: .standard(proto: "open_arguments"),
    4: .standard(proto: "torch_state"),
    5: .standard(proto: "zoom_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try {
        var v: Messages_OpenArguments?
        var hadOneofValue = false
        if let current = self.stub {
          hadOneofValue = true
          if case .openArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stub = .openArguments(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.stub != nil {try decoder.handleConflictingOneOf()}
          self.stub = .torchState(v)
        }
      }()
      case 5: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.stub != nil {try decoder.handleConflictingOneOf()}
          self.stub = .zoomValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.category != .open {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    switch self.stub {
    case .openArguments?: try {
      guard case .openArguments(let v)? = self.stub else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .torchState?: try {
      guard case .torchState(let v)? = self.stub else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .zoomValue?: try {
      guard case .zoomValue(let v)? = self.stub else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_Command, rhs: Messages_Command) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.category != rhs.category {return false}
    if lhs.stub != rhs.stub {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messages_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "category"),
    3: .same(proto: "quarterTurns"),
    4: .standard(proto: "torch_state"),
    5: .standard(proto: "zoom_value"),
    6: .same(proto: "image"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.stub != nil {try decoder.handleConflictingOneOf()}
          self.stub = .quarterTurns(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.stub != nil {try decoder.handleConflictingOneOf()}
          self.stub = .torchState(v)
        }
      }()
      case 5: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.stub != nil {try decoder.handleConflictingOneOf()}
          self.stub = .zoomValue(v)
        }
      }()
      case 6: try {
        var v: Messages_ImageProxy?
        var hadOneofValue = false
        if let current = self.stub {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stub = .image(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.category != .quarterTurnsChanged {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 2)
    }
    switch self.stub {
    case .quarterTurns?: try {
      guard case .quarterTurns(let v)? = self.stub else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }()
    case .torchState?: try {
      guard case .torchState(let v)? = self.stub else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .zoomValue?: try {
      guard case .zoomValue(let v)? = self.stub else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }()
    case .image?: try {
      guard case .image(let v)? = self.stub else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_Event, rhs: Messages_Event) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.category != rhs.category {return false}
    if lhs.stub != rhs.stub {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messages_OpenArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_OpenArguments, rhs: Messages_OpenArguments) -> Bool {
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messages_CameraSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CameraSelector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "facing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.facing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.facing != .back {
      try visitor.visitSingularEnumField(value: self.facing, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_CameraSelector, rhs: Messages_CameraSelector) -> Bool {
    if lhs.facing != rhs.facing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messages_CameraValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CameraValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "texture_value"),
    3: .standard(proto: "torch_value"),
    4: .standard(proto: "zoom_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._textureValue) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._torchValue) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._zoomValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._textureValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._torchValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._zoomValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_CameraValue, rhs: Messages_CameraValue) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._textureValue != rhs._textureValue {return false}
    if lhs._torchValue != rhs._torchValue {return false}
    if lhs._zoomValue != rhs._zoomValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messages_TextureValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextureValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .same(proto: "quarterTurns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.quarterTurns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 3)
    }
    if self.quarterTurns != 0 {
      try visitor.visitSingularInt32Field(value: self.quarterTurns, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_TextureValue, rhs: Messages_TextureValue) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.quarterTurns != rhs.quarterTurns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messages_TorchValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TorchValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "available"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.available) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.available != false {
      try visitor.visitSingularBoolField(value: self.available, fieldNumber: 1)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_TorchValue, rhs: Messages_TorchValue) -> Bool {
    if lhs.available != rhs.available {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messages_ZoomValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZoomValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minimum"),
    2: .same(proto: "maximum"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.minimum) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.maximum) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minimum != 0 {
      try visitor.visitSingularDoubleField(value: self.minimum, fieldNumber: 1)
    }
    if self.maximum != 0 {
      try visitor.visitSingularDoubleField(value: self.maximum, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_ZoomValue, rhs: Messages_ZoomValue) -> Bool {
    if lhs.minimum != rhs.minimum {return false}
    if lhs.maximum != rhs.maximum {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Messages_ImageProxy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImageProxy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "data"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Messages_ImageProxy, rhs: Messages_ImageProxy) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.data != rhs.data {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
